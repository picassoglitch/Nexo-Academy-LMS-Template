from sqlmodel import Session
from src.core.events.database import get_db_session
from src.db.users import AnonymousUser, PublicUser, User, UserRead
from src.services.users.users import security_get_user
from config.config import get_nexo_config
from pydantic import BaseModel
from fastapi import Depends, HTTPException, Request, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from datetime import datetime, timedelta, timezone
from src.services.dev.dev import isDevModeEnabled
from src.services.users.users import security_verify_password
from src.security.security import ALGORITHM, SECRET_KEY
from fastapi_jwt_auth import AuthJWT
from fastapi_jwt_auth.exceptions import AuthJWTException
from typing import Optional

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")


#### JWT Auth ####################################################
class Settings(BaseModel):
    authjwt_secret_key: str = "secret" if isDevModeEnabled() else SECRET_KEY
    # Allow both headers (for access tokens) and cookies (for refresh tokens)
    authjwt_token_location = {"headers", "cookies"}
    authjwt_cookie_csrf_protect = False
    authjwt_access_token_expires = (
        False if isDevModeEnabled() else timedelta(hours=8).total_seconds()
    )
    authjwt_cookie_samesite = "lax"
    # In local dev we typically run over http://localhost, so secure cookies would never be set/sent.
    authjwt_cookie_secure = False if isDevModeEnabled() else True
    # Browsers generally ignore/deny Domain=localhost; host-only cookies are what we want in dev.
    authjwt_cookie_domain: Optional[str] = (
        None if isDevModeEnabled() else get_nexo_config().hosting_config.cookie_config.domain
    )


@AuthJWT.load_config  # type: ignore
def get_config():
    return Settings()


#### JWT Auth ####################################################


#### Classes ####################################################


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    username: str | None = None


#### Classes ####################################################
async def authenticate_user(
    request: Request,
    email: str,
    password: str,
    db_session: Session,
) -> User | bool:
    user = await security_get_user(request, db_session, email)
    if not user:
        return False
    if not security_verify_password(password, user.password):
        return False
    return user


def create_access_token(data: dict, expires_delta: timedelta | None = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


async def get_current_user(
    request: Request,
    Authorize: AuthJWT = Depends(),
    db_session: Session = Depends(get_db_session),
):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    # NOTE: jwt_optional() still raises if a token is *present but invalid/expired*.
    # In that case we treat the request as anonymous so public endpoints keep working
    # and the frontend can prompt the user to log in again.
    try:
        Authorize.jwt_optional()
        subject = Authorize.get_jwt_subject() or None
        token_data = TokenData(username=subject)  # type: ignore
    except (JWTError, AuthJWTException):
        return AnonymousUser()
    if subject:
        # Password-only site access: no DB users; synthetic identity from JWT subject
        if subject == "__site__":
            public_user = PublicUser(
                id=0,
                user_uuid="user_site",
                username="Member",
                first_name="Site",
                last_name="",
                email="site@nexo.local",
                avatar_image="",
                bio="",
                details={},
                profile={},
            )
            request.state.user = public_user
            return public_user
        if subject == "__admin__":
            public_user = PublicUser(
                id=-1,
                user_uuid="user_admin",
                username="Admin",
                first_name="Admin",
                last_name="",
                email="admin@nexo.local",
                avatar_image="",
                bio="",
                details={},
                profile={},
            )
            request.state.user = public_user
            return public_user
        # Normal login: subject is email, look up user in DB
        user = await security_get_user(request, db_session, email=token_data.username)  # type: ignore
        if user is None:
            raise credentials_exception
        public_user = PublicUser(**user.model_dump())
        request.state.user = public_user
        return public_user
    else:
        return AnonymousUser()


async def non_public_endpoint(current_user: UserRead | AnonymousUser):
    if isinstance(current_user, AnonymousUser):
        raise HTTPException(status_code=401, detail="Not authenticated")
